<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>Elemental Runner — 80s Mobile</title>
<style>
  html, body { margin:0; padding:0; background:#101018; height:100%; font-family:system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
  #wrap { position:fixed; inset:0; display:flex; flex-direction:column; }
  #hud {
    height:48px; min-height:48px; color:#eee; background:#161626; display:flex; align-items:center; gap:12px; padding:0 12px;
    font-weight:600; letter-spacing:.5px; user-select:none;
  }
  #hud .pill { padding:4px 10px; border-radius:8px; background:#23233a; }
  #hud .hearts { letter-spacing:2px; }
  #hud .score { margin-left:auto; }
  #game { flex:1; position:relative; background:#0d0d16; }
  canvas { width:100%; height:100%; image-rendering: pixelated; image-rendering: crisp-edges; }
  #controls {
    height:28vh; min-height:140px; background:linear-gradient(180deg,#141428,#0c0c18);
    display:grid; grid-template-columns:1fr 1fr; gap:12px; padding:12px; touch-action:none; user-select:none;
  }
  .cluster { display:flex; gap:12px; align-items:center; justify-content:center; }
  .btn {
    flex:1; padding:16px; border-radius:14px; background:#22223a; color:#eaeaff; font-size:18px; font-weight:700;
    border:2px solid #2f2f52; box-shadow:0 6px 0 #121225; text-align:center;
  }
  .btn:active { transform:translateY(2px); box-shadow:0 4px 0 #121225; }
  .btn.small { flex:0 0 46%; font-size:16px; padding:14px; }
  .hint { position:absolute; bottom:30vh; left:50%; transform:translateX(-50%); color:#9aa; font-size:12px; opacity:.6; }
  /* Element chips */
  .chip { display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border-radius:999px; background:#202038; }
  .dot { width:12px; height:12px; border-radius:50%; display:inline-block; }
</style>
</head>
<body>
<div id="wrap">
  <div id="hud">
    <span id="elemChip" class="chip">
      <span class="dot" id="elemDot"></span>
      <span id="elemName">FIRE</span>
    </span>
    <span class="pill">Rule: Fire→Earth→Air→Water→Fire</span>
    <span class="pill hearts" id="hearts">❤❤❤</span>
    <span class="pill score" id="score">0</span>
  </div>
  <div id="game">
    <canvas id="c"></canvas>
    <div class="hint">Short-tap POWER to switch element • Hold POWER to cast</div>
  </div>
  <div id="controls">
    <div class="cluster">
      <button class="btn small" id="left">◀ LEFT</button>
      <button class="btn small" id="right">RIGHT ▶</button>
    </div>
    <div class="cluster">
      <button class="btn small" id="jump">JUMP ⤴</button>
      <button class="btn small" id="power">POWER ✦</button>
    </div>
  </div>
</div>

<script>
(function(){
  // --- Canvas & sizing ---
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  function resize(){ canvas.width = Math.floor(window.innerWidth / 2); canvas.height = Math.floor((window.innerHeight*0.72) / 2); }
  window.addEventListener('resize', resize, {passive:true}); resize();

  // --- Elements & colors ---
  const ELEMENTS = [
    {name:'FIRE',   key:'F', color:'#ff5b3a', beats:'EARTH'},
    {name:'EARTH',  key:'E', color:'#8cc84b', beats:'AIR'},
    {name:'AIR',    key:'A', color:'#e0e6ff', beats:'WATER'},
    {name:'WATER',  key:'W', color:'#35a7ff', beats:'FIRE'},
  ];
  let elemIndex = 0;
  const elemNameEl = document.getElementById('elemName');
  const elemDotEl  = document.getElementById('elemDot');
  function updateElemHUD(){
    const e = ELEMENTS[elemIndex];
    elemNameEl.textContent = e.name;
    elemDotEl.style.background = e.color;
  }
  updateElemHUD();

  // --- HUD ---
  const heartsEl = document.getElementById('hearts');
  const scoreEl  = document.getElementById('score');
  let score = 0;
  let hearts = 3;
  function updateHUD(){ heartsEl.textContent = '❤'.repeat(hearts); scoreEl.textContent = score; }
  updateHUD();

  // --- World ---
  const GROUND_Y = () => canvas.height - 28;  // ground line
  let t = 0; // time
  let speed = 1.3; // world scroll speed baseline; grows slowly
  // Player
  const player = {
    x: 24, y: GROUND_Y()-16, w: 14, h: 16, vx:0, vy:0, onGround:true, invul:0
  };
  // Input
  const input = { left:false, right:false, jump:false, powerTap:false, powerHold:false };
  // Buttons
  function bindBtn(id, onDown, onUp){
    const el = document.getElementById(id);
    let touchId = null;
    const down = (e)=>{ e.preventDefault(); onDown(); };
    const up   = (e)=>{ e.preventDefault(); onUp(); };
    el.addEventListener('touchstart', e=>{ if(touchId!==null) return; touchId = true; down(e); }, {passive:false});
    el.addEventListener('touchend',   e=>{ touchId=null; up(e); }, {passive:false});
    el.addEventListener('touchcancel',e=>{ touchId=null; up(e); }, {passive:false});
    el.addEventListener('mousedown', down);
    el.addEventListener('mouseup',   up);
    el.addEventListener('mouseleave',()=>{ if(touchId===null) up(new Event('mouseup')); });
  }
  bindBtn('left', ()=>input.left=true,  ()=>input.left=false);
  bindBtn('right',()=>input.right=true, ()=>input.right=false);
  bindBtn('jump', ()=>{ input.jump=true; }, ()=>{ input.jump=false; });

  // Power button: short tap cycles element; long press casts
  let powerDownAt = 0, casting = false;
  bindBtn('power',
    ()=>{ powerDownAt = performance.now(); casting=false; },
    ()=>{
      const dt = performance.now() - powerDownAt;
      if(dt >= 250){ casting = true; tryCast(); } else { cycleElement(); }
    }
  );
  function cycleElement(){ elemIndex = (elemIndex+1) % ELEMENTS.length; updateElemHUD(); }

  // Projectiles
  const shots = []; // {x,y,vx,vy, from:'player'|'enemy', color}
  function shoot(from, x,y, dir, color){
    shots.push({x,y, vx: dir*2.4, vy:0, from, color});
  }

  // Enemies
  const robots = []; // {x,y,w,h, elem, speed, size}
  let spawnTimer = 0;
  function spawnRobot(){
    const e = ELEMENTS[(Math.random()*ELEMENTS.length)|0];
    const size = 1 + Math.min(1.2, score/120); // grows with score
    const w=14*size, h=16*size;
    robots.push({
      x: canvas.width + 10, y: GROUND_Y()-h, w, h,
      elem: e, speed: speed + Math.random()*0.6 + score/400, size
    });
  }

  // Casting logic
  function beats(aName, bName){ return ELEMENTS.find(e=>e.name===aName).beats === bName; }
  function tryCast(){
    // Find nearest robot in front within range
    const range = 60;
    const e = ELEMENTS[elemIndex];
    let target = null, bestd = 9999;
    for(const r of robots){
      const dx = r.x - player.x;
      if(dx >= -10 && dx <= range){
        if(dx < bestd){ bestd = dx; target = r; }
      }
    }
    if(target){
      if(beats(e.name, target.elem.name)){
        // Good hit
        score += Math.round(10 * target.size);
        popText(target.x, target.y-8, '✔', '#8ef');
        // Remove
        robots.splice(robots.indexOf(target),1);
      }else{
        // Wrong: enemy shoots
        enemyShoot(target);
        popText(target.x, target.y-8, '✖', '#f88');
      }
    }else{
      // No target: fire a short-range blast anyway (cosmetic)
      shoot('player', player.x+player.w+2, player.y+player.h/2, 1, ELEMENTS[elemIndex].color);
    }
    updateHUD();
  }
  function enemyShoot(r){
    shoot('enemy', r.x-2, r.y+r.h/2, -1, r.elem.color);
  }

  // Pop text
  const pops = []; // {x,y,txt,color,t}
  function popText(x,y,txt,color){ pops.push({x,y,txt,color,t:0}); }

  // Physics & game loop
  function reset(){
    robots.length = 0; shots.length = 0; pops.length = 0;
    score=0; hearts=3; speed=1.3; t=0;
    player.x=24; player.y=GROUND_Y()-player.h; player.vx=0; player.vy=0; player.onGround=true; player.invul=0;
    updateHUD();
  }

  function step(){
    t += 1/60;
    ctx.imageSmoothingEnabled = false;

    // Difficulty scaling
    speed = 1.3 + Math.min(1.2, score/200);
    spawnTimer -= 1/60;
    if(spawnTimer <= 0){
      spawnRobot();
      const base = 1.6 - Math.min(1.0, score/250);
      spawnTimer = base + Math.random()*0.8;
    }

    // Background
    ctx.fillStyle = '#0d0d16'; ctx.fillRect(0,0,canvas.width,canvas.height);
    // Parallax stripes
    ctx.fillStyle = '#0f0f1f'; for(let i=0;i<canvas.width;i+=24){ ctx.fillRect((i - (t*15)%24)|0, canvas.height-60, 6, 40); }
    // Ground
    ctx.fillStyle = '#1a1a2e'; ctx.fillRect(0, GROUND_Y(), canvas.width, 999);

    // Input to velocity
    const moveSpeed = 1.4;
    player.vx = (input.right?moveSpeed:0) - (input.left?moveSpeed:0);
    if(input.jump && player.onGround){ player.vy = -3.1; player.onGround=false; }

    // Gravity
    player.vy += 0.15;
    player.y += player.vy;
    if(player.y + player.h >= GROUND_Y()){ player.y = GROUND_Y()-player.h; player.vy=0; player.onGround=true; }

    // Keep inside
    if(player.x < 4) player.x = 4;
    if(player.x > canvas.width*0.6) player.x = canvas.width*0.6;

    // Draw player (shield + body + sword)
    const flicker = player.invul>0 && ((t*30|0)%2===0);
    if(!flicker){
      // Shield (left)
      ctx.fillStyle = '#b3b7ff'; ctx.fillRect(player.x-4, player.y+4, 4, 8);
      // Body
      ctx.fillStyle = '#ffd166'; ctx.fillRect(player.x, player.y, player.w, player.h);
      // Helmet stripe
      ctx.fillStyle = '#333'; ctx.fillRect(player.x+3, player.y+1, 8, 2);
      // Sword
      ctx.fillStyle = '#c0c4d8'; ctx.fillRect(player.x+player.w, player.y+6, 10, 2);
    }

    // Robots update & draw
    for(let i=robots.length-1;i>=0;i--){
      const r = robots[i];
      r.x -= r.speed;
      // Remove offscreen
      if(r.x + r.w < -20){ robots.splice(i,1); continue; }
      // Draw
      ctx.fillStyle = '#23233a'; ctx.fillRect(r.x-2, r.y+r.h-3, r.w+4, 3); // shadow
      ctx.fillStyle = r.elem.color; ctx.fillRect(r.x, r.y, r.w, r.h);
      ctx.fillStyle = '#0b0b12'; ctx.fillRect(r.x+2, r.y+3, 4, 4); // eye
      // Element letter
      ctx.fillStyle = '#0b0b12'; ctx.font = '8px monospace'; ctx.fillText(r.elem.key, r.x+r.w-6, r.y+10);
      // Contact: if robot touches player x-range, it stops to engage & may shoot occasionally
      const inRange = (r.x - player.x) < 60 && (r.x - player.x) > -10;
      if(inRange && Math.random()<0.005){ enemyShoot(r); }
    }

    // Shots
    for(let i=shots.length-1;i>=0;i--){
      const s = shots[i];
      s.x += s.vx; s.y += s.vy;
      // Draw
      ctx.fillStyle = s.color; ctx.fillRect(s.x, s.y, 6, 2);
      if(s.x < -20 || s.x > canvas.width+20){ shots.splice(i,1); continue; }
      // Collisions
      if(s.from==='player'){
        for(let j=robots.length-1;j>=0;j--){
          const r = robots[j];
          if(s.x < r.x+r.w && s.x+6 > r.x && s.y < r.y+r.h && s.y+2 > r.y){
            // Player bullet does small chip if wrong element (not instant kill here)
            robots.splice(j,1);
            score += 5;
            shots.splice(i,1);
            break;
          }
        }
      }else{
        // Enemy hit player
        if(s.x < player.x+player.w && s.x+6 > player.x && s.y < player.y+player.h && s.y+2 > player.y){
          shots.splice(i,1);
          if(player.invul<=0){
            hearts -= 1; updateHUD();
            player.invul = 1.4; // seconds
            popText(player.x, player.y-6, '-1', '#f77');
            if(hearts<=0){ gameOver(); return; }
          }
        }
      }
    }

    // Invulnerability timer
    if(player.invul>0) player.invul -= 1/60;

    // Pops
    for(let i=pops.length-1;i>=0;i--){
      const p = pops[i]; p.t += 1/60; p.y -= 0.2;
      ctx.fillStyle = p.color; ctx.font = '10px monospace'; ctx.fillText(p.txt, p.x, p.y);
      if(p.t>0.8) pops.splice(i,1);
    }

    // Foreground scanline
    ctx.fillStyle='rgba(255,255,255,0.03)'; for(let y=0;y<canvas.height;y+=3){ ctx.fillRect(0,y,canvas.width,1); }

    requestAnimationFrame(step);
  }

  function gameOver(){
    // Overlay
    ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#fff'; ctx.font='16px monospace';
    ctx.fillText('GAME OVER', canvas.width/2-42, canvas.height/2-8);
    ctx.fillText('Score: '+score, canvas.width/2-36, canvas.height/2+12);
    setTimeout(reset, 1200);
  }

  // Start
  reset(); step();

  // Optional: keyboard for desktop testing
  window.addEventListener('keydown', (e)=>{
    if(e.code==='ArrowLeft') input.left=true;
    if(e.code==='ArrowRight') input.right=true;
    if(e.code==='Space' || e.code==='ArrowUp') input.jump=true;
    if(e.code==='KeyQ'){ cycleElement(); }
    if(e.code==='KeyE'){ tryCast(); }
  });
  window.addEventListener('keyup', (e)=>{
    if(e.code==='ArrowLeft') input.left=false;
    if(e.code==='ArrowRight') input.right=false;
    if(e.code==='Space' || e.code==='ArrowUp') input.jump=false;
  });
})();
</script>
</body>
</html>